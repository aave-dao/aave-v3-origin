<table>
    <tr><th></th><th></th></tr>
    <tr>
        <td><img src="https://raw.githubusercontent.com/aave-dao/aave-brand-kit/refs/heads/main/Logo/Logomark-purple.svg" width="250" height="250" style="padding: 4px;" /></td>
        <td>
            <h1>Aave v3.4 Upgrade Report</h1>
            <p>Prepared for: Aave DAO</p>
            <p>Code produced by: BGD Labs</p>
            <p>Report prepared by: Emanuele Ricci (StErMi), Independent Security Researcher</p>
        </td>
    </tr>
</table>
# Introduction

A time-boxed security review of the **Aave v3.4 Upgrade** protocol was done by **StErMi**, with a focus on the security aspects of the application's smart contracts implementation.

# Disclaimer

A smart contract security review can never verify the complete absence of vulnerabilities. This is a time, resource and expertise bound effort where I try to find as many vulnerabilities as possible. I can not guarantee 100% security after the review or even if the review will find any problems with your smart contracts. Subsequent security reviews, bug bounty programs and on-chain monitoring are strongly recommended.

# About **Aave v3.4 Upgrade**

Aave v3.4 is an upgrade to the Aave v3 protocol, currently running on v3.3 in production across all networks.
It includes the following changes and improvements:

- Migration of the custom GHO logic and a/v tokens to a model the same as any other asset, to simplify overall the codebase and its reasoning.
- Addition of Multicall support on the Pool contract.
- Introduction of a Position Manager role for users to assign to other addresses, allowing them to do a subset of actions on their behalf: switching Liquid modes, and enabling/disabling an asset as collateral.
- Removal of the unused BridgeLogic and the concept of “unbacked” in the protocol, never used either.
- Make different variables immutables, to align with the high-level nature of never-to-be-changed.
- Refactor the Error logic to use Error signatures instead of error codes.
- In addition to the migration of GHO from custom to standard, unification of aTokens’ storage and implementation for all assets (aAAVE was different from others due to its role in governance voting).
- Upgrade the compilation version to 0.8.27 to improve overall compatibility with tooling and dependencies.
- Multiple minor misc improvements and optimizations.

An exhaustive explanation of all changes included can be found on [Aave-v3.4-features.md](https://github.com/aave-dao/aave-v3-origin/blob/468e5dc4e5c3fbb40ef3dafdf76d7cb4f4e0f015/docs/3.4/Aave-v3.4-features.md)

References:

- [BGD. Aave v3.4](https://governance.aave.com/t/arfc-bgd-aave-v3-4/21572)

# About **StErMi**

**StErMi**, is an independent smart contract security researcher. He serves as a Lead Security Researcher at Spearbit and has identified multiple bugs in the wild on Immunefi and on protocol's bounty programs like the Aave Bug Bounty.

Do you want to connect with him?

- [stermi.xyz website](https://stermi.xyz/)
- [@StErMi on Twitter](https://twitter.com/StErMi)

# Summary & Scope

**_review commit hash_ - [`186d51e653fcc02a43d55dd361d7efa5941053c1`](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1)**
**_fix review commit hash_ - [`ffacf2f2ec821d52f76f302851a66a2322a0e72b`](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/ffacf2f2ec821d52f76f302851a66a2322a0e72b)**

# Severity classification

| Severity               | Impact: High | Impact: Medium | Impact: Low |
| ---------------------- | ------------ | -------------- | ----------- |
| **Likelihood: High**   | Critical     | High           | Medium      |
| **Likelihood: Medium** | High         | Medium         | Low         |
| **Likelihood: Low**    | Medium       | Low            | Low         |

**Impact** - the technical, economic and reputation damage of a successful attack
**Likelihood** - the chance that a particular vulnerability gets discovered and exploited
**Severity** - the overall criticality of the risk

---

# Findings Summary

| ID                 | Title                                                                                                | Severity | Status    |
| ------------------ | ---------------------------------------------------------------------------------------------------- | -------- | --------- |
| [I-01]             | `GHO` mint and burn events generated by the upgrade should be documented and explained               | Info     | Ack       |
| [I-02]             | `UpgradePayloadMainnet` should ensure that `UNI` tokens supplied to the `POOL` have not been delated | Info     | Fixed     |
| [I-03]             | Missing sanity checks                                                                                | Info     | Fixed     |
| [I-04]             | Typos or missing documentation in natspec                                                            | Info     | Fixed     |
| [I-05]             | Bulk informational changes/refactor/suggestions                                                      | Info     | Fixed/Ack |
| [CROSSPOST][I-06]  | `VariableDebtToken` and `VariableDebtTokenMainnetInstanceGHO` storage layout should be aligned       | Info     | Ack       |
| [FIX REVIEW][L-01] | `UpgradePayloadMainnet` execution could fail to cover the whole `GHO` deficit                        | Low      | Fixed     |
| [FIX REVIEW][I-01] | Consider documenting the ad-hoc `grantRole` operation executed during the upgrade                    | Info     | Fixed     |

# [I-01] `GHO` mint and burn events generated by the upgrade should be documented and explained

## Context

1. [UpgradePayloadMainnet.sol#L114-L117](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayloadMainnet.sol#L114-L117)
2. [ATokenMainnetInstanceGHO.sol#L36](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/ATokenMainnetInstanceGHO.sol#L36)
3. [UpgradePayloadMainnet.sol#L170-L173](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayloadMainnet.sol#L170-L173)

## Description

During the v3.4 upgrade, the following operation relative to the `GHO` token will be performed

1. [`IGhoDirectMinter(FACILITATOR).mintAndSupply(level)`](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayloadMainnet.sol#L117): mint of `~165_421_508` millions of `GHO` with the mission of the `Transfer(address(0), GhoDirectMinter, amount)` event
2. [`IGhoToken(AaveV3EthereumAssets.GHO_UNDERLYING).burn(amount)`](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/ATokenMainnetInstanceGHO.sol#L36): burn of `~165_421_508` millions of `GHO` with the emission of the `Transfer(A_GHO_TOKEN, address(0), amount)` event
3. [`if (capacity > level) { IGhoDirectMinter(FACILITATOR).mintAndSupply(capacity - level); }`](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayloadMainnet.sol#L117): mint of `~ 200m - 165_421_508` millions of `GHO` with the emission of the `emit Transfer(address(0), GhoDirectMinter, amount)` event

Note: the above numbers are the one fetched on chain at the time of the security review.

## Recommendations

BGD should take in consideration to documenting and disclosing this information to allow dApp/monitoring tools and third-party integrators to be aware of the huge amount of `GHO` that will be minted and burned during the upgrade transaction.

**BGD:** ack. we'll be very clear on the aip

# [I-02] `UpgradePayloadMainnet` should ensure that `UNI` tokens supplied to the `POOL` have not been delated

## Context

- [UpgradePayloadMainnet.sol#L131-L132](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayloadMainnet.sol#L131-L132)

## Description

The v3.4 upgrade removes the `delegateUnderlyingTo` function of the current [`aUNI`](https://etherscan.io/address/0x21714092d90c7265f52fdfdae068ec11a23c6248) token that could have allowed the AAVE DAO to delegate the `UNI` tokens supplied to the `POOL`.

Before executing the `_defaultUpgrade();` function that will upgrade the implementation contract of the `aUNI` token (and lose the `delegateUnderlyingTo` function), the `UpgradePayloadMainnet` contract should:

1. verify that the `aUNI` token has not delegated his votes
2. if the votes have been delegated, the delegator must be resetted to `address(0)`

## Recommendations

BGD should execute the following logic before the execution of `_defaultUpgrade();`:

```solidity
// if the UNI_A_TOKEN has a delegatee, reset it
if( IDelegationToken(AaveV3EthereumAssets.UNI_UNDERLYING).delegates(AaveV3EthereumAssets.UNI_A_TOKEN) != address(0) ) {
	// this must be done by user with the role "Pool Admin" in the ACL
	DelegationAwareAToken(AaveV3EthereumAssets.UNI_A_TOKEN).delegateUnderlyingTo(address(0));
}
```

**StErMi:** the recommendations have been implemented in the commit [`e958112f995e3584c5528a3802a830773b8c3f9f`](https://github.com/bgd-labs/protocol-v3.4-upgrade/commit/e958112f995e3584c5528a3802a830773b8c3f9f)

# [I-03] Missing sanity checks

## Description

- [x] [UpgradePayloadMainnet.sol#L53-L75](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayloadMainnet.sol#L53-L75): the `UpgradePayloadMainnet.constructor` should perform the following sanity checks
  - `A_TOKEN_GHO_IMPL.POOL() == POOL`
  - `V_TOKEN_GHO_IMPL.POOL() == POOL`
  - `A_TOKEN_IMPL.POOL() == POOL`
  - `V_TOKEN_IMPL.POOL() == POOL`
  - `FACILITATOR.POOL() == POOL`

## Recommendations

BGD should fix all the issues listed in the above section.

**StErMi:** the recommendations have been implemented in the commit [`e958112f995e3584c5528a3802a830773b8c3f9f`](https://github.com/bgd-labs/protocol-v3.4-upgrade/commit/e958112f995e3584c5528a3802a830773b8c3f9f)

# [I-04] Typos or missing documentation in natspec

## Description

- [x] [UpgradePayloadMainnet.sol](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayloadMainnet.sol): inside `UpgradePayloadMainnet` and the documentation relative to the v3.4 upgrade processes, it should be documented and highlighted that the `GHO` reserve will remain with the `ReserveConfigurationMap.data` part of the "virtual accounting flag" turned to **`false`**, even if every getter will return the **hardcoded** value `true`.

## Recommendations

BGD should fix all the issues listed in the above section

**StErMi:** the virtual accounting flag for the `GHO` reserve will be turned to `true` in the commit [`e958112f995e3584c5528a3802a830773b8c3f9f`](https://github.com/bgd-labs/protocol-v3.4-upgrade/commit/e958112f995e3584c5528a3802a830773b8c3f9f)

# [I-05] Bulk informational changes/refactor/suggestions

## Description

- [x] [ATokenMainnetInstanceGHO.sol#L29-L30](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/ATokenMainnetInstanceGHO.sol#L29-L30): move the "reset" of the deprecated `aGHO` state variable from the `resolveFacilitator` to the `initialize` function (to be overridden) as already done for the `VariableDebtTokenMainnetInstanceGHO` migration contract. Note: the new `initialize` function must execute the logic that is being executed by `ATokenInstance.initialize`.
- [ ] [UpgradePayload.sol#L78](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayload.sol#L78): consider triggering `Pool.mintToTreasury` if the new `A_TOKEN_IMPL.TREASURY()` is different from the existing one associated to the `AReserve`. Otherwise, the already accounted (but not minted yet) shares will go to the new treasury instead to the old one.
- [ ] [Deploy.s.sol#L305](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/script/Deploy.s.sol#L305): move the `address council = 0x8513e6F37dBc52De87b166980Fa3F50639694B60;` defined in the `Deploy.s.sol` into the `AaveV3Ethereum.sol` contract and import directly from it.
- [x] [UpgradePayloadMainnet.sol#L85](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayloadMainnet.sol#L85): use a more "unique" label for the `GhoDirectMinter` facilitator. Maybe it could be "Core GhoDirectMinter". Note that "Core" has been suggested because it's the name of the Pool on the AAVE dApp.
- [x] [UpgradePayloadMainnet.sol#L107-L108](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayloadMainnet.sol#L107-L108) + [UpgradePayloadMainnet.sol#L138-L139](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayloadMainnet.sol#L138-L139) + [UpgradePayloadMainnet.sol#L149-L150](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayloadMainnet.sol#L149-L150) + [UpgradePayloadMainnet.sol#L160-L161](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayloadMainnet.sol#L160-L161): avoid using hardcoded values for the `name` and `symbol` of `aGHO`, `vGHO`, `aAAVE` and `vAAVE`. Fetch them directly from the existing token. Example: `ERC20(AaveV3EthereumAssets.GHO_A_TOKEN).name()` and `ERC20(AaveV3EthereumAssets.GHO_A_TOKEN).symbol()`
- [ ] [UpgradePayloadMainnet.sol#L134-L165](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/UpgradePayloadMainnet.sol#L134-L165): consider moving the upgrade of the `vGHO`, `aAAVE` and `vAAVE` tokens before the `_defaultUpgrade();` for better readability of the code and logic.
- [x] [VariableDebtTokenMainnetInstanceGHO.sol#L57-L59](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/VariableDebtTokenMainnetInstanceGHO.sol#L57-L59): move the "custom logic" (clean of internal storage) of the `VariableDebtTokenMainnetInstanceGHO.initialize` at the very beginning of the function's flow and add a dev comment to explain it. Even better if placed in an `internal` function that is called by the `initialize` function at the beginning of the flow (to be fully separated)

## Recommendations

BGD should consider fixing all the above listed suggestions.

**StErMi:**

1. Fixed in the commit [`e958112`](https://github.com/bgd-labs/protocol-v3.4-upgrade/commit/e958112f995e3584c5528a3802a830773b8c3f9f)
2. Acknowledged by BGD with the following statement: "we are certain the treasury is the same (it always has been for all tokens, for all pools of a network & even accross versions of aave)"
3. Acknowledged by BGD with the following statement: "we are aware current handling of multisigs is suboptimal, but we will not add it to AaveV3Ethereum as it's not related to that"
4. Fixed in the commit [`e958112`](https://github.com/bgd-labs/protocol-v3.4-upgrade/commit/e958112f995e3584c5528a3802a830773b8c3f9f)
5. Fixed in the commit [`e958112`](https://github.com/bgd-labs/protocol-v3.4-upgrade/commit/e958112f995e3584c5528a3802a830773b8c3f9f)
6. Acknowledged by BGD with the following statement: "i don't really agree with it being more readable tbh. I'd rather keep as it is."
7. Fixed in the commit [`e958112`](https://github.com/bgd-labs/protocol-v3.4-upgrade/commit/e958112f995e3584c5528a3802a830773b8c3f9f)

# [CROSSPOST][I-06] `VariableDebtToken` and `VariableDebtTokenMainnetInstanceGHO` storage layout should be aligned

⚠️ This issue was originally be already created for the AAVE v3.4 security review. See the issue "[I-02] `VariableDebtToken` and `VariableDebtTokenMainnetInstanceGHO` storage layout should be aligned" in that report.

## Context

- [VariableDebtToken.sol](https://github.com/aave-dao/aave-v3-origin/blob/468e5dc4e5c3fbb40ef3dafdf76d7cb4f4e0f015/src/contracts/protocol/tokenization/VariableDebtToken.sol)
- [VariableDebtTokenMainnetInstanceGHO.sol#L17-L30](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/186d51e653fcc02a43d55dd361d7efa5941053c1/src/VariableDebtTokenMainnetInstanceGHO.sol#L17-L30)

## Description

The v3.4 upgrade deployments will be responsible to also align the `vGHO` (`GHO` variable debt token) contract to the "standard" `VariableDebtToken` contract.

To accomplish that, both the contracts need to be also aligned at the storage structure and storage slot values. The current implementation (live on mainnet) of `vGHO` has some custom storage slots used for internal accounting that will be deprecated and cleaned by the upgrade process.

```solidity
  // These are additional variables that were in the v3.3 VToken for the GHO aToken
  // but there is no such variables in all other vTokens in both v3.3 and v3.4
  // so we need to clean them in case in future versions of vTokens it will be
  // needed to add new storage variables.
  // If we don't clean them, then the aToken for the GHO token will have non zero values
  // in these new variables that may be added in the future.
  address private _deprecated_ghoAToken;
  address private _deprecated_discountToken;
  address private _deprecated_discountRateStrategy;

  // This global variable can't be cleaned. The future vToken code upgrades should consider
  // that on this slot there can't be a new mapping because it holds some non-zero values
  // On this slot there can be only value types, not reference types.
  // mapping(address => GhoUserState) internal _deprecated_ghoUserState;
```

The current upgrade logic will:

- rename those variables with the `_deprecated_` suffix
- clean the value at deployment time
- comment the `_deprecated_ghoUserState` variable

The suggestion in this case is to go another step further to fully embrace the alignment of all the A/V tokens to use the same codebase, even if at the beginning it will be less "clean".

The first three will be cleaned during the deployment of the new `vGHO` contract, so they are free and safe to use also by new deployment of "normal" `vToken`.

But `_deprecated_ghoUserState` (that has been commented out currently) could be problematic. While it's true that the storage slot value of a `mapping` is indeed `0`, if a future version of `VariableDebtToken` is going to use it as another `mapping (address => something)` (and `vGHO` is upgraded to it), it could end up using the same storage position for the same `K` and so the `V` value could be already **dirty** with all the unexpected consequences and problems.

To solve this issue, BGD should:

- add a "stub" dummy storage value to the `VariableDebtToken`. These variables can be freely used in the future by both any standard `VariableDebtToken` and `vGHO`
- add a **NON** comment `__deprecatedSlot` to both the `VariableDebtToken` and `VariableDebtTokenMainnetInstanceGHO` that should replace the old `mapping(address => GhoUserState) internal _deprecated_ghoUserState` variable used by `vGHO`. This storage slot must be **skipped** by any future version of `VariableDebtToken` and `vGHO` to be on the safe side.

## Recommendations

BGD should carefully implement the above suggestions to fully align the implementation and deployment of the current and future release of both `vGHO` and `VariableDebtToken`

**BGD:** ack. We'll consider it for the next upgrade. For 3.4 it feels cleaner to separate them.

# [FIX REVIEW][L-01] `UpgradePayloadMainnet` execution could fail to cover the whole `GHO` deficit

## Context

- [UpgradePayloadMainnet.sol#L117-L119](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/ffacf2f2ec821d52f76f302851a66a2322a0e72b/src/UpgradePayloadMainnet.sol#L117-L119)

## Description

One of the goal of the `UpgradePayloadMainnet` execution is to reset the `GHO` reserve `deficit` before any additional upgrade action are executed.

```solidity
// 0. cover the existing reserve deficit for GHO
uint256 currentDeficitGHO = AaveV3Ethereum.POOL.getReserveDeficit(AaveV3EthereumAssets.GHO_UNDERLYING);
if (currentDeficitGHO != 0) {
  IDeficitSteward(UmbrellaEthereum.DEFICIT_OFFSET_CLINIC_STEWARD).grantRole(FINANCE_COMMITTEE_ROLE, address(this));
  IDeficitSteward(UmbrellaEthereum.DEFICIT_OFFSET_CLINIC_STEWARD).coverDeficitOffset(
    AaveV3EthereumAssets.GHO_UNDERLYING
  );
}
```

Depending on the state of the `ghoReserve.deficit` and the `Umbrella` configuration (deficit pending and deficit offset) for the `GHO` asset at the moment of the execution, it's possible that, after executing the above code block, the `ghoReserve.deficit` **will not** be fully eliminated by `Umbrella`.

### Scenario 1: `pendingDeficit + deficitOffset <= poolDeficit`, `pendingDeficit == 0`

- deficit pending = 0 GHO (current state from last block)
- deficit offset = 100k GHO (current state from last block)
- deficit reserve = 150k GHO (example's hypothesis)

Calling `DeficitOffsetClinicSteward.coverDeficitOffset(GHO)` or directly `UMBRELLA.coverDeficitOffset(GHO, 150k GHO)` will anyway **NOT** reach your goal of setting the `reserve.deficit` to zero.

```
call DeficitOffsetClinicSteward.coverDeficitOffset(GHO) -> UMBRELLA.coverDeficitOffset(GHO, 100k GHO)
	→ _coverDeficit(GHO, 100k GHO, 100k GHO);
	→ POOL().eliminateReserveDeficit(GHO, 100k);
	→ NEW deficit reserve = 50k GHO

"direct" call UMBRELLA.coverDeficitOffset(GHO, 150k GHO)
	→ _coverDeficit(GHO, 150k GHO, 100k GHO);
	→ POOL().eliminateReserveDeficit(GHO, 100k);
	→ NEW deficit reserve = 50k GHO
```

### Scenario 2: `pendingDeficit + deficitOffset > poolDeficit`, `pendingDeficit == 10k`

- deficit pending = `10k  GHO` (example's hypothesis)
- deficit offset = `100k GHO` (current state from last block)
- deficit reserve = `30k  GHO` (example's hypothesis)

The same issue (`reserve.deficit > 0` after the execution) is there also when we have `pendingDeficit + deficitOffset > poolDeficit` **BUT** `pendingDeficit > 0`

```
call DeficitOffsetClinicSteward.coverDeficitOffset(GHO) -> UMBRELLA.coverDeficitOffset(GHO, 20k GHO)
	→ _coverDeficit(GHO, 20k GHO, 20k GHO);
	→ POOL().eliminateReserveDeficit(GHO, 20k);
	→ NEW deficit reserve = 10k GHO

"direct" call UMBRELLA.coverDeficitOffset(GHO, 30k GHO)
	→ _coverDeficit(GHO, 30k GHO, 20k GHO);
	→ POOL().eliminateReserveDeficit(GHO, 20k);
	→ NEW deficit reserve = 10k GHO
```

## Recommendations

Depending on the state of the chain (reserve's deficit and Umbrella configuration), it's possible that operating only via the `DeficitOffsetClinicSteward` won't allow AAVE to eliminate the whole deficit.

If BGD does not intend to modify the `DeficitOffsetClinicSteward` contract's behavior or eliminate the deficit by "directly" interacting with the `Umbrella` contract, one possible safeguard would be to place a `require` statement after the `coverDeficitOffset` execution and revert if it does not satisfy the invariant.

```diff
// 0. cover the existing reserve deficit for GHO
uint256 currentDeficitGHO = AaveV3Ethereum.POOL.getReserveDeficit(AaveV3EthereumAssets.GHO_UNDERLYING);
if (currentDeficitGHO != 0) {
  IDeficitSteward(UmbrellaEthereum.DEFICIT_OFFSET_CLINIC_STEWARD).grantRole(FINANCE_COMMITTEE_ROLE, address(this));
  IDeficitSteward(UmbrellaEthereum.DEFICIT_OFFSET_CLINIC_STEWARD).coverDeficitOffset(
    AaveV3EthereumAssets.GHO_UNDERLYING
  );
+  require(AaveV3Ethereum.POOL.getReserveDeficit(AaveV3EthereumAssets.GHO_UNDERLYING) == 0, "GHO deficit not fully eliminated");
}
```

**StErMi:** The recommendations have been implemented in the commit [`c813f9991f4329b6f9b3031df53fea22744b24d7`](https://github.com/bgd-labs/protocol-v3.4-upgrade/commit/c813f9991f4329b6f9b3031df53fea22744b24d7).

The upgrade will revert if the `GHO` reserve still have a `deficit > 0` after the execution of `coverDeficitOffset`

# [FIX REVIEW][I-01] Consider documenting the ad-hoc `grantRole` operation executed during the upgrade

## Context

- [UpgradePayloadMainnet.sol#L116](https://github.com/bgd-labs/protocol-v3.4-upgrade/blob/ffacf2f2ec821d52f76f302851a66a2322a0e72b/src/UpgradePayloadMainnet.sol#L116)

## Description

Without any knowledge of the context, the `grantRole` operation to provide the `FINANCE_COMMITTEE_ROLE` role to the `UpgradePayloadMainnet` contract itself seems a "one-shot" role granting operation that should be revoked as soon as the `coverDeficitOffset` function has been executed.

BGD has provided the following statement to explain the ad-hoc operation and why the role has not been revoked:

> The role is given to the short executor(who is already the default admin), and not revoked on purpose, as we think it's reasonable to give the DAO the possibility to cover deficit via Governance proposals.

## Recommendations

BGD should consider adding a dev comment that clarifies why the role is granted in that specific code (the implicit reason is clear, otherwise the `coverDeficitOffset` would revert) and why the role does not need to be revoked after the `coverDeficitOffset` execution.

**StErMi:** The recommendations have been implemented in the commit [`745f359f27166fc3aa13910953bae809067ee41b`](https://github.com/bgd-labs/protocol-v3.4-upgrade/commit/745f359f27166fc3aa13910953bae809067ee41b)
