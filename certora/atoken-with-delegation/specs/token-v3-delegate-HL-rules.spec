
/*==============================================================================================
  This is a specification file for the verification of delegation features.
  This file was adapted from AaveTokenV3.sol smart contract to ATOKEN-WITH-DELEGATION smart contract.
  This file is run by the command line: 
                certoraRun --send_only certora/conf/token-v3-delegate.conf
  It uses the harness file: certora/harness/ATokenWithDelegation_Harness.sol
  
  IMPORTANT:
  ---------
  The rules are verified under the following strong assumption:
              _SymbolicLendingPoolL1.getReserveNormalizedIncome() == RAY().
  That means that the liquidity index is 1.
  =============================================================================================*/

import "base_token_v3.spec";
import "token-v3-delegate-invariants.spec";




rule no_function_changes_both_balance_and_delegation_state(method f, address bob)
  filtered {f -> f.contract == currentContract}
{
  env e;
  calldataarg args;

  require (bob != 0);
  
  uint256 bob_balance_before = balanceOf(bob);
  bool is_bob_delegating_voting_before = isDelegatingVoting(bob);
  address bob_delegatee_before = mirror_votingDelegatee[bob];
  
  f(e,args);
  
  uint256 bob_balance_after = balanceOf(bob);
  bool is_bob_delegating_voting_after = isDelegatingVoting(bob);
  address bob_delegatee_after = mirror_votingDelegatee[bob];
  
  assert (bob_balance_before != bob_balance_after =>
          (is_bob_delegating_voting_before==is_bob_delegating_voting_after &&
           bob_delegatee_before == bob_delegatee_after)
         );
  
  assert (bob_delegatee_before != bob_delegatee_after =>
          bob_balance_before == bob_balance_after
         );
  
  assert (is_bob_delegating_voting_before!=is_bob_delegating_voting_after =>
          bob_balance_before == bob_balance_after            
         );
}
   


//===================================================================================
//===================================================================================
// High-level rules that verify that a change in the balance (generated by any function)
// results in a correct change in the power.
//===================================================================================
//===================================================================================

/*
    @Rule

    @Description:
        Verify correct voting power after any change in (any user) balance.
        We consider the following case:
        - bob is the delegatee of alice1, and possibly of alice2. No other user delegates
        to bob.
        - bob may be delegating and may not.
        - We assume that the function that was call doesn't change the delegation state of neither
          bob, alice1 or alice2.

        We emphasize that we assume that no function alters both the balance of a user (Bob),
        and its delegation state (including the delegatee). We indeed check this property in the
        rule no_function_changes_both_balance_and_delegation_state().
        
    @Note:

    @Link:
*/
rule vp_change_in_balance_affect_power_DELEGATEE(method f,address bob,address alice1,address alice2)
  filtered {f -> f.contract == currentContract}
{
  require index()==RAY();
  env e;
  calldataarg args;
  require bob != 0; require alice1 != 0; require alice2 != 0;
  require (bob != alice1 && bob != alice2 && alice1 != alice2);
  
  uint256 bob_bal_before = balanceOf(bob);
  mathint bob_power_before = getPowerCurrent(bob, VOTING_POWER());
  bool is_bob_delegating_before = isDelegatingVoting(bob);
  
  uint256 alice1_bal_before = balanceOf(alice1);
  bool is_alice1_delegating_before = isDelegatingVoting(alice1);
  address alice1D_before = getVotingDelegatee(alice1); // alice1D == alice1_delegatee
  uint256 alice2_bal_before = balanceOf(alice2);
  bool is_alice2_delegating_before = isDelegatingVoting(alice2);
  address alice2D_before = getVotingDelegatee(alice2); // alice2D == alice2_delegatee
  
  // The following says that alice1 is delegating to bob, alice2 may do so, and no other
  // user may do so.
  require (is_alice1_delegating_before && alice1D_before == bob);
  require forall address a. (a!=alice1 && a!=alice2) =>
    (mirror_votingDelegatee[a] != bob ||
     (mirror_delegationMode[a]!=VOTING_DELEGATED() &&
      mirror_delegationMode[a]!=FULL_POWER_DELEGATED()
     )
    );
  
  requireInvariant value_of_sum_all_voting_delegated_power_OK(bob);
  requireInvariant value_of_sum_all_voting_delegated_power_OK(alice1);
  requireInvariant value_of_sum_all_voting_delegated_power_OK(alice2);
  requireInvariant user_cant_voting_delegate_to_himself();
  requireInvariant inv_voting_power_correct(alice1);
  requireInvariant inv_voting_power_correct(alice2);
  requireInvariant inv_voting_power_correct(bob);

  f(e,args);
  
  uint256 alice1_bal_after = balanceOf(alice1);
  mathint alice1_power_after = getPowerCurrent(alice1,VOTING_POWER());
  bool is_alice1_delegating_after = isDelegatingVoting(alice1);
  address alice1D_after = getVotingDelegatee(alice1); // alice1D == alice1_delegatee
  uint256 alice2_bal_after = balanceOf(alice2);
  mathint alice2_power_after = getPowerCurrent(alice2,VOTING_POWER());
  bool is_alice2_delegating_after = isDelegatingVoting(alice2);
  address alice2D_after = getVotingDelegatee(alice2); // alice2D == alice2_delegatee
  
  require (is_alice1_delegating_after && alice1D_after == bob);
  require forall address a. (a!=alice1 && a!=alice2) =>
    (mirror_votingDelegatee[a] != bob ||
     (mirror_delegationMode[a]!=VOTING_DELEGATED() &&
      mirror_delegationMode[a]!=FULL_POWER_DELEGATED()
     )
    );
  // No change in the delegation state of alice2
  require (is_alice2_delegating_before==is_alice2_delegating_after &&
           alice2D_before == alice2D_after);
  
  uint256 bob_bal_after = balanceOf(bob);
  mathint bob_power_after = getPowerCurrent(bob, VOTING_POWER());
  bool is_bob_delegating_after = isDelegatingVoting(bob);
  
  // No change in the delegation state of bob
  require (is_bob_delegating_before == is_bob_delegating_after);
  
  mathint alice1_diff = 
    (is_alice1_delegating_after && alice1D_after==bob) ?
    normalize(alice1_bal_after) - normalize(alice1_bal_before) : 0;
  
  mathint alice2_diff = 
    (is_alice2_delegating_after && alice2D_after==bob) ?
    normalize(alice2_bal_after) - normalize(alice2_bal_before) : 0;
  
  mathint bob_diff = bob_bal_after - bob_bal_before;
  
  assert
    !is_bob_delegating_after =>
    bob_power_after == bob_power_before + alice1_diff + alice2_diff + bob_diff;
  
  assert
    is_bob_delegating_after =>
    bob_power_after == bob_power_before + alice1_diff + alice2_diff;
}



/*
  @Rule
  
  @Description:
  Verify correct voting power after any change in (any user) balance.
  We consider the following case:
  - No user is delegating to bob.
  - bob may be delegating and may not.
  - We assume that the function that was call doesn't change the delegation state of bob.
  
  We emphasize that we assume that no function alters both the balance of a user (Bob),
  and its delegation state (including the delegatee). We indeed check this property in the
  rule no_function_changes_both_balance_and_delegation_state().
        
  @Note:
  
  @Link:
*/
rule vp_change_of_balance_affect_power_NON_DELEGATEE(method f, address bob)
  filtered {f -> f.contract == currentContract}
{
  require index()==RAY();
  env e;
  calldataarg args;
  require bob != 0;
  
  uint256 bob_bal_before = balanceOf(bob);
  mathint bob_power_before = getPowerCurrent(bob, VOTING_POWER());
  bool is_bob_delegating_before = isDelegatingVoting(bob);
  
  // The following says the no one delegates to bob
  require forall address a. 
    (mirror_votingDelegatee[a] != bob ||
     (mirror_delegationMode[a]!=VOTING_DELEGATED() &&
      mirror_delegationMode[a]!=FULL_POWER_DELEGATED()
     )
    );
  
  requireInvariant value_of_sum_all_voting_delegated_power_OK(bob);
  requireInvariant user_cant_voting_delegate_to_himself();
  requireInvariant inv_voting_power_correct(bob);
  
  f(e,args);
  
  require forall address a. 
    (mirror_votingDelegatee[a] != bob ||
     (mirror_delegationMode[a]!=VOTING_DELEGATED() &&
      mirror_delegationMode[a]!=FULL_POWER_DELEGATED()
     )
    );
  
  uint256 bob_bal_after = balanceOf(bob);
  mathint bob_power_after = getPowerCurrent(bob, VOTING_POWER());
  bool is_bob_delegating_after = isDelegatingVoting(bob);
  mathint bob_diff = bob_bal_after - bob_bal_before;
  
  require (is_bob_delegating_before == is_bob_delegating_after);
  
  assert !is_bob_delegating_after => bob_power_after==bob_power_before + bob_diff;
  assert is_bob_delegating_after => bob_power_after==bob_power_before;
}




/*
  @Rule
  
  @Description:
  Verify correct proposition power after any change in (any user) balance.
  We consider the following case:
  - bob is the delegatee of alice1, and possibly of alice2. No other user delegates
  to bob.
  - bob may be delegating and may not.
  - We assume that the function that was call doesn't change the delegation state of neither
  bob, alice1 or alice2.
  
  We emphasize that we assume that no function alters both the balance of a user (Bob),
  and its delegation state (including the delegatee). We indeed check this property in the
  rule no_function_changes_both_balance_and_delegation_state().
  
  @Note:
  
  @Link:
*/
rule pp_change_in_balance_affect_power_DELEGATEE(method f,address bob,address alice1,address alice2)
  filtered {f -> f.contract == currentContract}
{
  require index()==RAY();
  env e;
  calldataarg args;
  require bob != 0; require alice1 != 0; require alice2 != 0;
  require (bob != alice1 && bob != alice2 && alice1 != alice2);
  
  uint256 bob_bal_before = balanceOf(bob);
  mathint bob_power_before = getPowerCurrent(bob, PROPOSITION_POWER());
  bool is_bob_delegating_before = isDelegatingProposition(bob);
  
  uint256 alice1_bal_before = balanceOf(alice1);
  bool is_alice1_delegating_before = isDelegatingProposition(alice1);
  address alice1D_before = getPropositionDelegatee(alice1); // alice1D == alice1_delegatee
  uint256 alice2_bal_before = balanceOf(alice2);
  bool is_alice2_delegating_before = isDelegatingProposition(alice2);
  address alice2D_before = getPropositionDelegatee(alice2); // alice2D == alice2_delegatee
  
  // The following says that alice1 is delegating to bob, alice2 may do so, and no other
  // user may do so.
  require (is_alice1_delegating_before && alice1D_before == bob);
  require forall address a. (a!=alice1 && a!=alice2) =>
    (mirror_propositionDelegatee[a] != bob ||
     (mirror_delegationMode[a]!=PROPOSITION_DELEGATED() &&
      mirror_delegationMode[a]!=FULL_POWER_DELEGATED()
     )
    );
  
  requireInvariant value_of_sum_all_proposition_delegated_power_OK(bob);
  requireInvariant value_of_sum_all_proposition_delegated_power_OK(alice1);
  requireInvariant value_of_sum_all_proposition_delegated_power_OK(alice2);
  requireInvariant user_cant_proposition_delegate_to_himself();
  requireInvariant inv_proposition_power_correct(alice1);
  requireInvariant inv_proposition_power_correct(alice2);
  requireInvariant inv_proposition_power_correct(bob);
  
  f(e,args);
  
  uint256 alice1_bal_after = balanceOf(alice1);
  mathint alice1_power_after = getPowerCurrent(alice1,PROPOSITION_POWER());
  bool is_alice1_delegating_after = isDelegatingProposition(alice1);
  address alice1D_after = getPropositionDelegatee(alice1); // alice1D == alice1_delegatee
  uint256 alice2_bal_after = balanceOf(alice2);
  mathint alice2_power_after = getPowerCurrent(alice2,PROPOSITION_POWER());
  bool is_alice2_delegating_after = isDelegatingProposition(alice2);
  address alice2D_after = getPropositionDelegatee(alice2); // alice2D == alice2_delegatee
  
  require (is_alice1_delegating_after && alice1D_after == bob);
  require forall address a. (a!=alice1 && a!=alice2) =>
    (mirror_propositionDelegatee[a] != bob ||
     (mirror_delegationMode[a]!=PROPOSITION_DELEGATED() &&
      mirror_delegationMode[a]!=FULL_POWER_DELEGATED()
     )
    );
  // No change in the delegation state of alice2
  require (is_alice2_delegating_before==is_alice2_delegating_after &&
           alice2D_before == alice2D_after);
  
  uint256 bob_bal_after = balanceOf(bob);
  mathint bob_power_after = getPowerCurrent(bob, PROPOSITION_POWER());
  bool is_bob_delegating_after = isDelegatingProposition(bob);
  
  // No change in the delegation state of bob
  require (is_bob_delegating_before == is_bob_delegating_after);
  
  mathint alice1_diff = 
    (is_alice1_delegating_after && alice1D_after==bob) ?
    normalize(alice1_bal_after) - normalize(alice1_bal_before) : 0;
  
  mathint alice2_diff = 
    (is_alice2_delegating_after && alice2D_after==bob) ?
    normalize(alice2_bal_after) - normalize(alice2_bal_before) : 0;
  
  mathint bob_diff = bob_bal_after - bob_bal_before;
  
  assert
    !is_bob_delegating_after =>
    bob_power_after == bob_power_before + alice1_diff + alice2_diff + bob_diff;
  
  assert
    is_bob_delegating_after =>
    bob_power_after == bob_power_before + alice1_diff + alice2_diff;
}



/*
    @Rule

    @Description:
        Verify correct proposition power after any change in (any user) balance.
        We consider the following case:
        - No user is delegating to bob.
        - bob may be delegating and may not.
        - We assume that the function that was call doesn't change the delegation state of bob.

        We emphasize that we assume that no function alters both the balance of a user (Bob),
        and its delegation state (including the delegatee). We indeed check this property in the
        rule no_function_changes_both_balance_and_delegation_state().
        
    @Note:

    @Link:
*/

rule pp_change_of_balance_affect_power_NON_DELEGATEE(method f, address bob)
  filtered {f -> f.contract == currentContract}
{
  require index()==RAY();
  env e;
  calldataarg args;
  require bob != 0;
  
  uint256 bob_bal_before = balanceOf(bob);
  mathint bob_power_before = getPowerCurrent(bob, PROPOSITION_POWER());
  bool is_bob_delegating_before = isDelegatingProposition(bob);
  
  // The following says the no one delegates to bob
  require forall address a. 
    (mirror_propositionDelegatee[a] != bob ||
     (mirror_delegationMode[a]!=PROPOSITION_DELEGATED() &&
      mirror_delegationMode[a]!=FULL_POWER_DELEGATED()
     )
    );
  
  requireInvariant value_of_sum_all_proposition_delegated_power_OK(bob);
  requireInvariant user_cant_proposition_delegate_to_himself();
  requireInvariant inv_proposition_power_correct(bob);
  
  f(e,args);
  
  require forall address a. 
    (mirror_propositionDelegatee[a] != bob ||
     (mirror_delegationMode[a]!=PROPOSITION_DELEGATED() &&
      mirror_delegationMode[a]!=FULL_POWER_DELEGATED()
     )
    );
  
  uint256 bob_bal_after = balanceOf(bob);
  mathint bob_power_after = getPowerCurrent(bob, PROPOSITION_POWER());
  bool is_bob_delegating_after = isDelegatingProposition(bob);
  mathint bob_diff = bob_bal_after - bob_bal_before;
  
  require (is_bob_delegating_before == is_bob_delegating_after);
  
  assert !is_bob_delegating_after => bob_power_after==bob_power_before + bob_diff;
  assert is_bob_delegating_after => bob_power_after==bob_power_before;
}




